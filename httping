#!/usr/bin/env python3
#
# Usage via URL:
#   # Test IPv4 connectivity
#   python3 <(curl -sL https://raw.githubusercontent.com/crzidea/local-bin/refs/heads/master/httping) https://ipv4.icanhazip.com/cdn-cgi/trace
#
#   # Test IPv6 connectivity
#   python3 <(curl -sL https://raw.githubusercontent.com/crzidea/local-bin/refs/heads/master/httping) https://ipv6.icanhazip.com/cdn-cgi/trace
#

import argparse
import time
import sys
import signal
import statistics
from urllib.request import urlopen, Request
from urllib.error import URLError, HTTPError
from urllib.parse import urlparse

# Optional imports for HTTP/3
try:
    import asyncio
    from aioquic.asyncio.client import connect
    from aioquic.h3.connection import H3_ALPN, H3Connection
    from aioquic.h3.events import DataReceived, HeadersReceived
    from aioquic.quic.configuration import QuicConfiguration
    from aioquic.quic.events import QuicEvent
    HAS_AIOQUIC = True
except ImportError:
    HAS_AIOQUIC = False

# Global stats for summary
stats = {
    'sent': 0,
    'received': 0,
    'rtts': []
}

def signal_handler(sig, frame):
    print_summary()
    sys.exit(0)

class RequestTimeout(Exception):
    pass

def timeout_handler(signum, frame):
    raise RequestTimeout("Request timed out")

def print_summary():
    print(f"\n--- {args.url} httping statistics ---")
    loss = 0
    if stats['sent'] > 0:
        loss = (stats['sent'] - stats['received']) / stats['sent'] * 100
    
    print(f"{stats['sent']} requests transmitted, {stats['received']} received, {loss:.1f}% loss")
    
    if stats['rtts']:
        min_rtt = min(stats['rtts'])
        avg_rtt = statistics.mean(stats['rtts'])
        max_rtt = max(stats['rtts'])
        stddev_rtt = statistics.stdev(stats['rtts']) if len(stats['rtts']) > 1 else 0.0
        print(f"rtt min/avg/max/mdev = {min_rtt:.3f}/{avg_rtt:.3f}/{max_rtt:.3f}/{stddev_rtt:.3f} ms")

def parse_trace(content):
    data = {}
    try:
        lines = content.decode('utf-8').splitlines()
        for line in lines:
            if '=' in line:
                key, value = line.split('=', 1)
                data[key.strip()] = value.strip()
    except Exception:
        pass
    return data


def main():
    global args
    parser = argparse.ArgumentParser(description='Ping-like tool for HTTP requests')
    parser.add_argument('url', help='Target URL')
    parser.add_argument('-c', '--count', type=int, default=float('inf'), help='Number of requests to send')
    parser.add_argument('-i', '--interval', type=float, default=1.0, help='Interval between requests in seconds')
    parser.add_argument('-W', '--timeout', type=float, default=2.0, help='Time in seconds to wait for a reply (default: 2.0)')
    parser.add_argument('--http3', action='store_true', help='Use HTTP/3 (QUIC) protocol (requires aioquic)')
    
    args = parser.parse_args()
    
    # Auto-prepend http:// if missing
    if not args.url.startswith(('http://', 'https://')):
        args.url = 'http://' + args.url
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGALRM, timeout_handler)
    
    print(f"HTTPING {args.url}")
    
    parsed_url = urlparse(args.url)
    is_trace = parsed_url.path == '/cdn-cgi/trace'
    
    seq = 0
    try:
        while seq < args.count:
            seq += 1
            stats['sent'] += 1
            
            start_time = time.time()
            try:
                if args.http3:
                    if not HAS_AIOQUIC:
                        print("Error: --http3 requires 'aioquic' library.")
                        print("Please install it using: pip install aioquic")
                        sys.exit(1)
                    
                    # We define the async function LOCALLY here to access everything easily and keep it self contained
                    # This avoids global scope pollution with async objects until needed.
                    async def perform_h3():
                        from aioquic.asyncio.protocol import QuicConnectionProtocol
                        
                        class H3ResponseInfo:
                             def __init__(self):
                                 self.headers = []
                                 self.content = b""
                                 self.status_code = 0
                                 self.done = asyncio.Event()

                        resp_info = H3ResponseInfo()

                        class H3ClientProtocol(QuicConnectionProtocol):
                            def __init__(self, *args, **kwargs):
                                super().__init__(*args, **kwargs)
                                self._h3 = H3Connection(self._quic)

                            def quic_event_received(self, event):
                                for h3_event in self._h3.handle_event(event):
                                    if isinstance(h3_event, HeadersReceived):
                                        for h, v in h3_event.headers:
                                             if h == b":status":
                                                 resp_info.status_code = int(v.decode())
                                        resp_info.headers = h3_event.headers
                                    elif isinstance(h3_event, DataReceived):
                                        resp_info.content += h3_event.data
                                    
                                    # Check if stream is done
                                    # Note: aioquic H3 events don't explicitly explicitly say "Response Complete" easily 
                                    # unless stream_ended is true in DataReceived or HeadersReceived.
                                    if isinstance(h3_event, (DataReceived, HeadersReceived)) and h3_event.stream_ended:
                                        resp_info.done.set()

                        parsed = urlparse(args.url)
                        host = parsed.hostname
                        port = parsed.port or 443
                        path = parsed.path or "/"

                        configuration = QuicConfiguration(is_client=True, alpn_protocols=H3_ALPN)
                        configuration.verify_mode = 0 # Disable SSL verification for simplicity/compatibility as per httping vibes

                        async with connect(host, port, configuration=configuration, create_protocol=H3ClientProtocol) as protocol:
                            # Send Request
                            stream_id = protocol._quic.get_next_available_stream_id()
                            protocol._h3.send_headers(
                                stream_id=stream_id,
                                headers=[
                                    (b":method", b"GET"),
                                    (b":scheme", b"https"),
                                    (b":authority", host.encode()),
                                    (b":path", path.encode()),
                                    (b"user-agent", b"httping/0.1"),
                                ],
                                end_stream=True
                            )
                            # Manually trigger transmit for the headers we just queued
                            # The protocol loop in 'connect' usually handles transmit on timer, 
                            # but we can force it or wait.
                            # Since H3Connection queues frames, we need to flush them to QUIC.
                            protocol.transmit()

                            # Wait for response
                            await resp_info.done.wait()
                            return resp_info.status_code, resp_info.content

                    # Run the async loop
                    try:
                        status_code, content = asyncio.run(asyncio.wait_for(perform_h3(), timeout=args.timeout))
                    except asyncio.TimeoutError:
                        raise RequestTimeout("Request timed out")
                    
                    end_time = time.time()
                    duration_ms = (end_time - start_time) * 1000
                    stats['received'] += 1
                    stats['rtts'].append(duration_ms)
                    
                    connected_to = args.url # Simplify for H3
                    
                    extra_info = ""
                    if is_trace:
                        trace_data = parse_trace(content)
                        ip = trace_data.get('ip', 'N/A')
                        colo = trace_data.get('colo', 'N/A')
                        extra_info = f" ip={ip} colo={colo}"
                        
                    print(f"connected to {connected_to}: seq={seq} time={duration_ms:.2f} ms status={status_code}{extra_info}")

                else:
                    signal.setitimer(signal.ITIMER_REAL, args.timeout)
                    req = Request(args.url)
                    # Ensure we accept everything to mimic a standard browser/client slightly better, 
                    # mainly to avoid getting blocked by some basic filters if possible, 
                    # though urllib default user-agent is usually fine for basic checks.
                    with urlopen(req, timeout=args.timeout) as response:
                        connected_to = args.url
                        try:
                             # Attempt to get the IP address from the underlying socket
                             # Must be done before reading content as fp might be closed/cleared
                             if hasattr(response.fp, 'raw'):
                                 ip_addr = response.fp.raw._sock.getpeername()[0]
                                 connected_to = ip_addr
                             elif hasattr(response, 'fp') and hasattr(response.fp, '_sock'):
                                 # Fallback for some other structures
                                 ip_addr = response.fp._sock.getpeername()[0]
                                 connected_to = ip_addr
                        except Exception:
                             pass

                        content = response.read()
                        status_code = response.getcode()
                        
                        # Disable alarm immediately after read successfully
                        signal.setitimer(signal.ITIMER_REAL, 0)
                        
                        end_time = time.time()
                        duration_ms = (end_time - start_time) * 1000
                        stats['received'] += 1
                        stats['rtts'].append(duration_ms)
                        
                        extra_info = ""
                        if is_trace:
                            trace_data = parse_trace(content)
                            ip = trace_data.get('ip', 'N/A')
                            colo = trace_data.get('colo', 'N/A')
                            extra_info = f" ip={ip} colo={colo}"
                            
                        print(f"connected to {connected_to}: seq={seq} time={duration_ms:.2f} ms status={status_code}{extra_info}")
                    
            except RequestTimeout:
                 print(f"Request timeout for {args.url}: seq={seq}")
            except HTTPError as e:
                signal.setitimer(signal.ITIMER_REAL, 0)
                end_time = time.time()
                duration_ms = (end_time - start_time) * 1000
                print(f"connected to {args.url}: seq={seq} time={duration_ms:.2f} ms status={e.code}")
            except URLError as e:
                 signal.setitimer(signal.ITIMER_REAL, 0)
                 print(f"failed to connect to {args.url}: seq={seq} reason={e.reason}")
            except Exception as e:
                signal.setitimer(signal.ITIMER_REAL, 0)
                print(f"error: {e}")

            if seq < args.count:
                time.sleep(args.interval)
                
    except KeyboardInterrupt:
        # Handled by signal_handler, but just in case loop exits some other way
        pass
        
    print_summary()

if __name__ == "__main__":
    main()
