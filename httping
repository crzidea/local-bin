#!/usr/bin/env python3
#
# Usage via URL:
#   # Test IPv4 connectivity
#   python3 <(curl -sL https://raw.githubusercontent.com/crzidea/local-bin/refs/heads/master/httping) https://ipv4.icanhazip.com/cdn-cgi/trace
#
#   # Test IPv6 connectivity
#   python3 <(curl -sL https://raw.githubusercontent.com/crzidea/local-bin/refs/heads/master/httping) https://ipv6.icanhazip.com/cdn-cgi/trace
#

import argparse
import http.client
import signal
import socket
import statistics
import sys
import time
from urllib.parse import urlparse

# Optional imports for HTTP/3
try:
    import asyncio

    from aioquic.asyncio.client import connect
    from aioquic.h3.connection import H3_ALPN, H3Connection
    from aioquic.h3.events import DataReceived, HeadersReceived
    from aioquic.quic.configuration import QuicConfiguration
    from aioquic.quic.events import QuicEvent

    HAS_AIOQUIC = True
except ImportError:
    HAS_AIOQUIC = False

# Global stats for summary
stats = {"sent": 0, "received": 0, "rtts": []}


def signal_handler(sig, frame):
    print_summary()
    sys.exit(0)


class RequestTimeout(Exception):
    pass


def timeout_handler(signum, frame):
    raise RequestTimeout("Request timed out")


def print_summary():
    print(f"\n--- {args.url} httping statistics ---")
    loss = 0
    if stats["sent"] > 0:
        loss = (stats["sent"] - stats["received"]) / stats["sent"] * 100

    print(
        f"{stats['sent']} requests transmitted, {stats['received']} received, {loss:.1f}% loss"
    )

    if stats["rtts"]:
        min_rtt = min(stats["rtts"])
        avg_rtt = statistics.mean(stats["rtts"])
        max_rtt = max(stats["rtts"])
        stddev_rtt = statistics.stdev(stats["rtts"]) if len(stats["rtts"]) > 1 else 0.0
        print(
            f"rtt min/avg/max/mdev = {min_rtt:.3f}/{avg_rtt:.3f}/{max_rtt:.3f}/{stddev_rtt:.3f} ms"
        )


def parse_trace(content):
    data = {}
    try:
        lines = content.decode("utf-8").splitlines()
        for line in lines:
            if "=" in line:
                key, value = line.split("=", 1)
                data[key.strip()] = value.strip()
    except Exception:
        pass
    return data


def main():
    global args
    parser = argparse.ArgumentParser(description="Ping-like tool for HTTP requests")
    parser.add_argument("url", help="Target URL")
    parser.add_argument(
        "-c",
        "--count",
        type=int,
        default=float("inf"),
        help="Number of requests to send",
    )
    parser.add_argument(
        "-i",
        "--interval",
        type=float,
        default=1.0,
        help="Interval between requests in seconds",
    )
    parser.add_argument(
        "-W",
        "--timeout",
        type=float,
        default=2.0,
        help="Time in seconds to wait for a reply (default: 2.0)",
    )
    parser.add_argument(
        "--http3",
        action="store_true",
        help="Use HTTP/3 (QUIC) protocol (requires aioquic)",
    )

    args = parser.parse_args()

    # Auto-prepend http:// if missing
    if not args.url.startswith(("http://", "https://")):
        args.url = "http://" + args.url

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGALRM, timeout_handler)

    if args.http3:
        if not HAS_AIOQUIC:
            print("Error: --http3 requires 'aioquic' library.")
            print("Please install it using: pip install aioquic")
            sys.exit(1)

        try:
            asyncio.run(run_http3_session(args))
        except KeyboardInterrupt:
            pass
    else:
        run_http1_session(args)

    print_summary()


async def run_http3_session(args):
    # Local imports to avoid global requirement
    from aioquic.asyncio.protocol import QuicConnectionProtocol

    class H3ResponseInfo:
        def __init__(self):
            self.headers = []
            self.content = b""
            self.status_code = 0
            self.done = asyncio.Event()

    class H3ClientProtocol(QuicConnectionProtocol):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self._h3 = H3Connection(self._quic)
            self.req_events = (
                {}
            )  # Map flow_id or similar if needed, but for sequential we can simplify

        def quic_event_received(self, event):
            # Pass event to H3 connection
            for h3_event in self._h3.handle_event(event):
                # We need to find which request this belongs to if we were concurrent.
                # Since we are sequential/ping-like, we can use a single active request context
                # or just fire events.
                if isinstance(h3_event, HeadersReceived):
                    # We assume single stream active for simple ping
                    if hasattr(self, "current_resp"):
                        for h, v in h3_event.headers:
                            if h == b":status":
                                self.current_resp.status_code = int(v.decode())
                        self.current_resp.headers = h3_event.headers
                elif isinstance(h3_event, DataReceived):
                    if hasattr(self, "current_resp"):
                        self.current_resp.content += h3_event.data

                if (
                    isinstance(h3_event, (DataReceived, HeadersReceived))
                    and h3_event.stream_ended
                ):
                    if hasattr(self, "current_resp"):
                        self.current_resp.done.set()

    parsed = urlparse(args.url)
    host = parsed.hostname
    port = parsed.port or 443
    path = parsed.path or "/"

    configuration = QuicConfiguration(is_client=True, alpn_protocols=H3_ALPN)

    # We need to handle IP resolution manually if we want to print connected IP like requests does,
    # but aioquic connect takes host/port.

    print(f"HTTPING {args.url}")

    seq = 0
    try:
        async with connect(
            host, port, configuration=configuration, create_protocol=H3ClientProtocol
        ) as protocol:
            connected_to = host
            try:
                peername = protocol._transport.get_extra_info("peername")
                if (
                    not peername
                    and hasattr(protocol, "_quic")
                    and protocol._quic._network_paths
                ):
                    peername = protocol._quic._network_paths[0].addr
                if peername:
                    connected_to = peername[0]
                    if connected_to.startswith("::ffff:"):
                        connected_to = connected_to[7:]
            except Exception:
                pass

            while seq < args.count:
                seq += 1
                stats["sent"] += 1
                start_time = time.time()

                # Setup response object for this request
                resp_info = H3ResponseInfo()
                protocol.current_resp = (
                    resp_info  # Attach to protocol so callbacks find it
                )

                stream_id = protocol._quic.get_next_available_stream_id()
                protocol._h3.send_headers(
                    stream_id=stream_id,
                    headers=[
                        (b":method", b"GET"),
                        (b":scheme", b"https"),
                        (b":authority", host.encode()),
                        (b":path", path.encode()),
                        (b"user-agent", b"httping/0.1"),
                    ],
                    end_stream=True,
                )
                protocol.transmit()

                try:
                    await asyncio.wait_for(resp_info.done.wait(), timeout=args.timeout)

                    end_time = time.time()
                    duration_ms = (end_time - start_time) * 1000
                    stats["received"] += 1
                    stats["rtts"].append(duration_ms)

                    extra_info = ""
                    is_trace = parsed.path == "/cdn-cgi/trace"
                    if is_trace:
                        trace_data = parse_trace(resp_info.content)
                        ip = trace_data.get("ip", "N/A")
                        colo = trace_data.get("colo", "N/A")
                        extra_info = f" ip={ip} colo={colo}"

                    print(
                        f"connected to {connected_to}: seq={seq} time={duration_ms:.2f} ms status={resp_info.status_code}{extra_info}"
                    )

                except asyncio.TimeoutError:
                    print(f"Request timeout for {connected_to}: seq={seq}")
                except Exception as e:
                    print(f"error: {e}")

                if seq < args.count:
                    await asyncio.sleep(args.interval)

    except Exception as e:
        print(f"Connection error: {e}")


def run_http1_session(args):
    parsed = urlparse(args.url)
    host = parsed.hostname
    port = parsed.port
    scheme = parsed.scheme
    if not port:
        port = 443 if scheme == "https" else 80

    path = parsed.path or "/"
    if parsed.query:
        path += "?" + parsed.query

    is_trace = parsed.path == "/cdn-cgi/trace"

    print(f"HTTPING {args.url}")

    conn = None
    try:
        # Create connection object (lazy connect)
        if scheme == "https":
            conn = http.client.HTTPSConnection(host, port, timeout=args.timeout)

        else:
            conn = http.client.HTTPConnection(host, port, timeout=args.timeout)

        seq = 0
        while seq < args.count:
            seq += 1
            stats["sent"] += 1
            start_time = time.time()

            try:
                # request() auto-connects if needed
                conn.request("GET", path, headers={"User-Agent": "httping/0.1"})
                resp = conn.getresponse()
                content = resp.read()  # Read body to clear socket and allow reuse

                end_time = time.time()
                duration_ms = (end_time - start_time) * 1000
                stats["received"] += 1
                stats["rtts"].append(duration_ms)

                connected_to = host
                try:
                    if conn.sock:
                        connected_to = conn.sock.getpeername()[0]
                except Exception:
                    pass

                extra_info = ""
                if is_trace:
                    trace_data = parse_trace(content)
                    ip = trace_data.get("ip", "N/A")
                    colo = trace_data.get("colo", "N/A")
                    extra_info = f" ip={ip} colo={colo}"

                print(
                    f"connected to {connected_to}: seq={seq} time={duration_ms:.2f} ms status={resp.status}{extra_info}"
                )

            except socket.timeout:
                print(f"Request timeout for {args.url}: seq={seq}")
                conn.close()
            except (socket.error, http.client.HTTPException) as e:
                print(f"failed to connect to {args.url}: seq={seq} reason={e}")
                conn.close()
            except Exception as e:
                print(f"error: {e}")
                conn.close()

            if seq < args.count:
                time.sleep(args.interval)

    except KeyboardInterrupt:
        pass
    finally:
        if conn:
            conn.close()


if __name__ == "__main__":
    main()
